/**
 * HTTP协议 => 无状态协议 传输层协议  超文本传输协议
 * 基于TCP协议 => 基于UDP协议
 * 是客户机到服务器的请求和从服务器到客户机的响应进行约束和规范
 */
//当我们输入网址后发生了什么
//1.输入网址并回车 => 防火墙,是否能够连接到互联网 => DNS服务器(网址转换成IP地址(占用8*4个字节),后续都用IP作为地址IPV4(IPV6，IP地址数量多)，链路层协议) => 
//2.路由技术(路由器) => 透明设备 => 转发数据包
//3.发送HTTP请求(request)
//4.服务器处理请求
//5.服务器返回HTML响应(response)
//6.浏览器处理HTML页面
//7.继续请求其他资源

//HTTP请求模型


/**
 * TCP/IP协议
 */
// 应用层:为用户提供所需要的各种活动 例如 HTTP FTP DNS SMTP等
// (表示层)
// (会话层)
// 传输层: TCP(传输控制，可靠性)、UDP(用户数据报，不可靠)协议，主要解决端到端的通信
// 网络层：主要解决主机到主机的通信问题
// 数据链路层:
// 物理层(网络接口层: 负责监视数据在主机和网络之间的交换)


/**
 * 事物 => 一次HTTP操作
 */
//1. 首先客户机与服务器建立连接，只要点击某个超级连接，HTTP的工作开始(TCP层面)
//2. 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符(URL),协议版本号,后边的是MIME信息包括请求修饰符,客户机信息和可能的内容 （HTTP的request）
//3. 服务器接到请求后，给与相应的响应信息，其格式为一个状态行，包括信息的协议版本号，一个成功或者错误的代码，后边是MIME信息包括服务器信息，实体信息和可能的内容 (HTTP的response)
//4. 客户端接收到服务器返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接


/**
 * 请求方法
 * 1.get(请求行消息报头 请求正文为空)
 * 2.post(状态行 消息报头 响应正文)
 * 3.head: 请求获取由Request-URI所标识的资源的响应消息报头
 * 4.put
 * 5.delete
 * 6.trace: 请求服务器回送收到的请求信息，主要作为诊断或者测试
 * 7.connect: 改为管道方式的代理服务器
 * 8.options: 请求查询服务器的性能，或者查询与资源相关的选项和需求
 */

 /**
  * 状态码
  */


  /**
   * cookies 和 session
   * 
   */

   /**
    * HTTP缓存机制
    * 缓存在计算机的浏览器缓存区
    * 通过响应头中设置缓存协商
    */

    /**
     * HTTP 2
     * 使用二进制格式传输，更高效，更紧凑
     * 对报头压缩，降低开销
     * 多路复用(linux)，一个网络连接实现并行请求
     * 服务器主动推送，减少请求的延迟
     * 默认使用加密
     */

     /**
      * HTTP2伪头字段（前面带:的）
      * HTTP3 由HTTP-over-QUIC 改名  QUIC协议：Quick UDP Internet Connection 和HTTP1.1,HTTP2没有关系
      */


      /**
       * 代理(proxy)：不方便自己做的事情，让别人去做，这叫代理
       * 
       * 反向代理：nginx服务器
       * 请求转发，加密和SSL加速，负载均衡，缓存静态内容(图片，脚本，CSS)，压缩，减速上传(百度网盘限速)，安全(proxy=>web server =>others)，外网发布
       * 
       * 正向代理，不知道访问地址的IP
       * 监控，缓存，科学上网,网关
       */

       /**
        * nginx(事件驱动)
        * 进程：worker_processes 1;
        * 一个工作进程所能同时处理的并发数:events:{
        *   worker_connetions 1024;
        * }
        * upstream [name] {
        *   server [host]:[port] weigth=1;//权重
        *   server [host]:[port] weigth=1;
        *   server [host]:[port] weigth=1;
        * }
        * location /[othername]/ { //请求中含有/[othername]/=>转发到[name]下的[othername]
        * proxy_pass http://[name]/[othername]; //内网配成HTTPS没有意义
        * }
        */